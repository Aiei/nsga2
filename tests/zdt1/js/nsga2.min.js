var MOEA;!function(MOEA){class NSGA2{constructor(chromosomeSize,objectiveSize,populationSize,maxGenerations,objectiveFunction,genomeFunction){this.mutationRate=0,this.crossoverRate=0,this.chromosomeSize=chromosomeSize,this.objectiveSize=objectiveSize,this.populationSize=populationSize,this.maxGenerations=maxGenerations,this.genomeFunction=genomeFunction,this.objectiveFunction=objectiveFunction}optimize(frontOnly=!1){let timeStamp=Date.now(),pop;pop=this.initPopulation(pop),this.sort(pop),pop=this.setCrowdingDistances(pop);let generationCount=1;for(;generationCount<this.maxGenerations;){let offsprings=this.generateOffsprings(pop);pop=pop.concat(offsprings);let sortedPop=this.sort(pop);pop=this.setCrowdingDistances(pop);let nextPop=[],sortedPopLength=sortedPop.length;for(let i=0;i<sortedPopLength;i++)if(sortedPop[i].length+nextPop.length<=this.populationSize)nextPop=nextPop.concat(sortedPop[i]);else if(nextPop.length<this.populationSize){this.sortByCrowdingDistance(sortedPop[i]);let j=0;for(;nextPop.length<this.populationSize;)nextPop.push(sortedPop[i][j]),j++}pop=nextPop,generationCount++}if(console.log("NSGA2 Finished in "+(Date.now()-timeStamp)+" milliseconds."),frontOnly){let fpop=[];for(let p of pop)1==p.paretoRank&&fpop.push(p);return fpop}return pop}initPopulation(population){population=[];for(let i=0;i<this.populationSize;i++)population[i]=this.createRandomIndividual();return population}createRandomIndividual(){let newIndividual=new Individual;for(let i=0;i<this.chromosomeSize;i++)newIndividual.chromosome[i]=this.genomeFunction();return newIndividual.calculateObjectives(this.objectiveFunction),newIndividual}sort(individuals){let fronts=[];fronts[0]=[];let l=individuals.length;for(let i=0;i<l;i++){individuals[i].individualsDominated=[],individuals[i].dominatedCount=0;for(let j=0;j<l;j++)i!=j&&(individuals[i].dominate(individuals[j])?individuals[i].individualsDominated.push(individuals[j]):individuals[j].dominate(individuals[i])&&(individuals[i].dominatedCount+=1));individuals[i].dominatedCount<=0&&(individuals[i].paretoRank=1,fronts[0].push(individuals[i]))}let rank=0;for(;fronts[rank].length>0;){let nextFront=[];for(let k=0;k<fronts[rank].length;k++)for(let j=0;j<fronts[rank][k].individualsDominated.length;j++)fronts[rank][k].individualsDominated[j].dominatedCount-=1,0==fronts[rank][k].individualsDominated[j].dominatedCount&&(fronts[rank][k].individualsDominated[j].paretoRank=rank+2,nextFront.push(fronts[rank][k].individualsDominated[j]));fronts[rank+=1]=nextFront}return fronts}setCrowdingDistances(individuals){for(let i=0;i<individuals.length;i++)individuals[i].crowdingDistance=0;for(let m=0;m<this.objectiveSize;m++){let objectiveMin=1/0,objectiveMax=0,lastIndex;for(let idv of individuals)idv.objectives[m]>objectiveMax&&(objectiveMax=idv.objectives[m]),idv.objectives[m]<objectiveMin&&(objectiveMin=idv.objectives[m]);if(this.sortByObjective(individuals,m),!(objectiveMax-objectiveMin<=0)){individuals[0].crowdingDistance=1/0,individuals[individuals.length-1].crowdingDistance=1/0;for(let i=1;i<individuals.length-1;i++)individuals[i].crowdingDistance=individuals[i].crowdingDistance+(individuals[i+1].objectives[m]-individuals[i-1].objectives[m])/(objectiveMax-objectiveMin)}}return individuals}sortByObjective(individuals,objectiveId){let tmp;for(let i=0;i<individuals.length;i++)for(let j=i;j>0;j--)individuals[j].objectives[objectiveId]-individuals[j-1].objectives[objectiveId]<0&&(tmp=individuals[j],individuals[j]=individuals[j-1],individuals[j-1]=tmp)}generateOffsprings(parents){let offsprings=[];for(;offsprings.length<this.populationSize;){let parentA=this.getGoodParent(parents),parentB=this.getGoodParent(parents),childs=this.mate(parentA,parentB);offsprings.push(childs[0],childs[1])}return offsprings}mate(parentA,parentB){let childs=[new Individual,new Individual];return childs[0].chromosome=parentA.chromosome.slice(0,this.chromosomeSize),childs[1].chromosome=parentB.chromosome.slice(0,this.chromosomeSize),this.crossover(childs[0],childs[1],this.crossoverRate),this.mutate(childs[0],this.mutationRate),this.mutate(childs[1],this.mutationRate),childs[0].calculateObjectives(this.objectiveFunction),childs[1].calculateObjectives(this.objectiveFunction),childs}crossover(a,b,rate){for(let i=0;i<this.chromosomeSize;i++)if(Math.random()<this.crossoverRate){let tmp=a.chromosome[i];a.chromosome[i]=b.chromosome[i],b.chromosome[i]=tmp}}mutate(individual,rate){for(let i=0;i<individual.chromosome.length;i++)Math.random()<rate&&(individual.chromosome[i]=this.genomeFunction())}getGoodParent(parents){let r;do{r=[Math.floor(Math.random()*parents.length),Math.floor(Math.random()*parents.length)]}while(r[0]==r[1]);if(parents[r[0]].paretoRank<parents[r[1]].paretoRank)return parents[r[0]];if(parents[r[0]].paretoRank>parents[r[1]].paretoRank)return parents[r[1]];if(parents[r[0]].paretoRank==parents[r[1]].paretoRank){if(parents[r[0]].crowdingDistance>=parents[r[1]].crowdingDistance)return parents[r[0]];if(parents[r[0]].crowdingDistance<parents[r[1]].crowdingDistance)return parents[r[1]]}}sortByCrowdingDistance(individuals){let tmp;for(let i=0;i<individuals.length;i++)for(let j=i;j>0;j--)individuals[j].crowdingDistance-individuals[j-1].crowdingDistance<0&&(tmp=individuals[j],individuals[j]=individuals[j-1],individuals[j-1]=tmp);individuals.reverse()}}MOEA.NSGA2=NSGA2;class Individual{constructor(){this.chromosome=[],this.objectives=[]}calculateObjectives(objectiveFunction){this.objectives=objectiveFunction(this.chromosome)}dominate(other){let l=this.objectives.length;for(let i=0;i<l;i++)if(this.objectives[i]>other.objectives[i])return!1;return!0}}MOEA.Individual=Individual}(MOEA||(MOEA={}));